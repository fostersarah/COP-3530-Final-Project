vector<int> dijkstra(const Graph& graph, int src) {
    int s = src;
    
    int vertices = graph.numVertices;
    vector<int> distance;
    for (int i = 0; i < vertices; i++)
    {
        distance.push_back(INT_MAX);
    }
    distance[src] = 0;
    int previous[vertices];
    for (int i = 0; i < vertices; i++)
    {
        previous[i] = -1;
    }
    
    set<int> computed;
    set<int> processing;
    for (int i = 0; i < vertices; i++)
    {
        processing.insert(i);
    }
    computed.insert(src);
    processing.erase(src);
    
    while (!processing.empty())
    {
        for (int i = 0; i < graph.adjList[s].size(); i++)
        {
            if (distance[graph.adjList[s][i].first] > distance[s] + graph.adjList[s][i].second)
            {
                distance[graph.adjList[s][i].first] = distance[s] + graph.adjList[s][i].second;
                previous[graph.adjList[s][i].first] += 1;
            }
        }
        computed.insert(s);
        processing.erase(s);
        // find new s by making sure it is the smallest in distance but not in computed

        int min = INT_MAX;
        for (int i = 0; i < vertices; i++)
        {
            if (distance[i] < min && computed.count(i) == 0)
            {
                min = distance[i];
                s = i;
            }
        }
    }
   
    return distance;                                                                         
}
