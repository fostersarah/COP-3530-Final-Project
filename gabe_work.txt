-get all movie names and genres, organized by pair. (toy story, {family, animation, comedy})
-as we get those ^ we are looking through the genres, and inserting the pair vector<movie> family -> family.push(toy story)
into a vector for each genre.
-for each genre container: family
	for each movie in container: 
		compare movie to all other movies in container:
			calculate weight of matching genres:
				we know we already have 1 match, we're checking for additional
			add pair to set so we dont compare the two again if more than one matching
				in future, we check set to see if two movies have been compared
			add comparisons to map through adjacency


-get movie names and list of genre from csv.
-add pair (name, genres) to data structure relative to genre.
-for each genre container:
	-compare one movie to all other movies in container
		-calculate the weight of edge between them based on ~percent matching genres
		-add movie pair to set, so they are not recalculated
		-remove movie from genre container, so it is not recompared
		-add movie pair to adjacency list with calculated weight (movie, movie, weight)
	-move to next movie in list


for i = 0; i < family.size; i++
	for int j = i+i; j < family.size; j++
		if ((family[i],family[j]) in set)
			skip
		compare family[i] and family[j] (calculate edge weight)
		set.add(family[i],family[j])
		adjList.add(family[i],family[j],weight)




-------------------------------------------------------------------------------------------------------------------
map<string, movie> catalogue;
// movie.name, movie
int numMovies;
// self explanatory
-------------------------------------------------------------------------------------------------------------------
set of genres
vector of genres.
create a map<string, vector<movie>> movies // key is the genre, value is the vector of movies with that genre

-> we get a movie object that has name and genre list.

for (int i = 0; i < movie.genre.size(); i++)
	movies[movie.genre[i]].push_back(movie);

set<string> completed;

for (int i = 0; i < genres.size(); i++)
{
	for (int j = 0; j < movies[genres[i]].size(); j++)
	{
		for (int k = j+1; k < movies[genres[i]].size(); k++)
		{
			string orient1 = movies[genres[i]][j].name + movies[genres[i]][k].name;
			string orient2 = movies[genres[i]][k].name + movies[genres[i]][j].name;
			
			if (completed.count(orient1) != 0 || completed.count(orient2) != 0)
			{
				continue;
			}
			else
			{
				completed.insert(orient1);
				completed.insert(orient2);
			}

			int weight = calculateWeight(movies[genres[i]][j], movies[genres[i]][k]);
			
			Edge edge1 = new Edge(movies[genres[i]][j].name, movies[genres[i]][k].name, weight)
			Edge edge2 = new Edge(movies[genres[i]][k].name, movies[genres[i]][j].name, weight)


			edges.push_back(edge1);
			edges.push_back(edge2);
		{
	{
{
----------------------------------------------------------------------------------------------------------------

the user is going to give us movie names as a string so we want the key to the map to be a string.
we're going to have to have another way to store all movie objects so that they're accessible by string
struct Edge
{
	string src, dest;
	int weight;
	Edge(string _src, string _dest, int _weight) 
	{
		src = _src;
		dest = _dest;
		weight = _weight;
	}
};

class Graph
{
public:
	int numVertices;
	map <string, vector<pair<string,int>>> adjList;

	Graph(const vector<Edge>& edges, int vertices)
	{
		numVertices = vertices;
		for (auto &edge : edges)
		{
			adjList[edge.src].push_back(make_pair(edge.dest, edge.weight));
		}
	}
};
